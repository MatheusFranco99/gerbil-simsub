* A PubSub Protocol and its Simulator

This is a pubsub protocol, dubbed ~gossipsub~, aka ~meshsub/1.0.0~.
The basic idea is to start from a connected network with an arbitrary
degree and reduce it to a mesh with a specific degree. Messages are
forwarded through the reduced mesh. The mesh is augmented by /gossip/
about forwarded messages, which is regularly forwarded to a random subset
of known peers with a heartbeat.

* Installation

The code is written in [[https://github.com/vyzo/gerbil][Gerbil]], and you can install it through the
Gerbil package manager:

#+BEGIN_EXAMPLE
$ gxpkg install github.com/vyzo/gerbil-simsub
#+END_EXAMPLE

* The gossipsub Protocol

The gossipsub router is implemented as an /actor/ in [[simsub/gossip.ss]].

** Protocol
The protocol is defined in two layers: basic pubsub, and gossipsub:

#+BEGIN_SRC gerbil
(defproto pubsub
  event:
  (connect)
  (publish id data))

(defproto gossipsub
  extend: pubsub
  event:
  (ihave ids)
  (iwant ids)
  (link)
  (unlink)
  (graft)
  (prune))
#+END_SRC

The baseline ~pubsub~ protocol specifies 2 messages:
+ ~CONNECT~ which establishes a symmetric connection to the peer.
+ ~PUBLISH~ which forwards a message to the peer.

The ~gossipsub~ protocol augments the baseline protocol with 6 control messages:
+ ~IHAVE~ is the gossip message, which specifies recent messages ids in the peer's
  history.
+ ~IWANT~ is used to ask for specific messages by id.
+ ~LINK~ is used to request grafting a mesh link.
+ ~UNLINK~ is used to request pruning of a mesh link.
+ ~GRAFT~ is used to notify a peer that a mesh link has been grafted.
+ ~PRUNE~ is used to notify a peer that a mesh link has been pruned.

** Overlay Parameters

#+BEGIN_SRC gerbil
(def N 6)                            ; target mesh degree
(def N-low 4)                        ; low water mark for mesh degree
(def N-high 12)                      ; high water mark for mesh degree

(def history-gossip 3)               ; length of gossip history
(def history-length 120)             ; length of total message history
#+END_SRC

** Actor State

#+BEGIN_SRC gerbil
  (def messages (make-hash-table-eqv))  ; messages seen: message-id -> data
  (def window [])                       ; messages in current window: [message-id ...]
  (def history [])                      ; message history: [window ...]
  (def peers [])                        ; connected peers
  (def D [])                            ; direct peers in the mesh
  (def heartbeat                        ; next heartbeat time
    (make-timeout (1+ (random-real))))
#+END_SRC

** Reaction Loop

#+BEGIN_SRC gerbil
  (def (loop)
    (<- ((!pubsub.connect)
         (unless (memq @source peers)
           (set! peers (cons @source peers))))

        ((!pubsub.publish id msg)
         (unless (hash-get messages id) ; seen?
           (hash-put! messages id msg)
           (set! window (cons id window))
           ;; deliver
           (receive id msg)
           ;; and forward
           (for (peer (remq @source D))
             (send! (!!pubsub.publish peer id msg)))))

        ((!gossipsub.ihave ids)
         (let (iwant (filter (lambda (id) (not (hash-get messages id)))
                             ids))
           (unless (null? iwant)
             (send! (!!gossipsub.iwant @source iwant)))))

        ((!gossipsub.iwant ids)
         (for (id ids)
           (alet (msg (hash-get messages id))
             (send! (!!pubsub.publish @source id msg)))))

        ((!gossipsub.link)
         (unless (memq @source D)
           (set! D (cons @source D))
           (send! (!!gossipsub.graft @source))))

        ((!gossipsub.unlink)
         (when (memq @source D)
           (set! D (remq @source D))
           (send! (!!gossipsub.prune @source))))

        ((!gossipsub.graft)
         (unless (memq @source D)
           (set! D (cons @source D))))

        ((!gossipsub.prune)
         (when (memq @source D)
           (set! D (remq @source D))))

        (! heartbeat (heartbeat!)))
    (loop))
#+END_SRC

** Heartbeat

#+BEGIN_SRC gerbil
  (def (heartbeat!)
    (def d (length D))

    ;; overlay management
    (when (< d N-low)
      ;; we need some links, send LINK to some peers
      (let* ((i-need (- N d))
             (candidates (filter (lambda (peer) (not (memq peer D)))
                                 peers))
             (candidates (shuffle candidates))
             (candidates (if (> (length candidates) i-need)
                           (take candidates i-need)
                           candidates)))
        (for (peer candidates)
          (send! (!!gossipsub.link peer)))))

    (when (> d N-high)
      ;; we have too many links, send UNLINK to some peers
      (let* ((to-drop (- d N))
             (candidates (shuffle D))
             (candidates (take candidates to-drop)))
        (for (peer candidates)
          (send! (!!gossipsub.unlink peer)))))

    ;; message history management
    (set! history (cons window history))
    (set! window [])
    (when (> (length history) history-length)
      (let (ids (last history))
        (set! history
          (drop-right history 1))
        (for (id ids)
          (hash-remove! messages id))))

    ;; gossip about messages in our history (if any)
    (let (ids (foldl (lambda (window r) (foldl cons r window))
                     []
                     (if (> (length history) history-gossip)
                       (take history history-gossip)
                       history)))
      (unless (null? ids)
        (let* ((peers (shuffle peers))
               (peers (if (> (length peers) N)
                        (take peers N)
                        peers)))
          (for (peer peers)
            (send! (!!gossipsub.ihave peer ids))))))

    (set! heartbeat (make-timeout 1)))
#+END_SRC

** Initialization

#+BEGIN_SRC gerbil
  (def (connect new-peers)
    (let (new-peers (filter (lambda (peer) (not (memq peer peers)))
                            new-peers))
      (for (peer new-peers)
        (send! (!!pubsub.connect peer)))
      (set! peers
        (foldl cons peers new-peers))))

  (connect initial-peers)
  (loop)
#+END_SRC


* Simulation

The [[simsub/simulator.ss][simulator]] constructs a network of ~N~ nodes, and randomly connects
it with a connectivity degree ~N-connect~.
There is a random latency between any pair of nodes, selected uniformly
in the ~[.01s, .15s]~ interval.
The simulation [[simsub/scripts.ss][script]] sends a number ~M~ of messages, by selecting ~fanout~ random
peers and publishing to them. Each successive message is sent after some delay
~M-delay~.

#+BEGIN_EXAMPLE
$ gxi
> (import :vyzo/simsub/scripts)
> (simple-gossipsub-simulation trace: void) ; N = 100, N-connect = 10, M = 10, M-delay = 1
=== simulation summary ===
nodes: 100
messages: 10
fanout: 5
publish: 50
deliver: 1000
!!gossipsub.ihave: 7218
!!gossipsub.link: 364
!!gossipsub.graft: 364
!!pubsub.connect: 1000
!!gossipsub.iwant: 3
!!pubsub.publish: 6281

> (simple-gossipsub-simulation trace: void messages: 100 message-delay: .1)
=== simulation summary ===
nodes: 100
messages: 100
fanout: 5
publish: 500
deliver: 10000
!!gossipsub.ihave: 7812
!!gossipsub.link: 374
!!gossipsub.graft: 374
!!pubsub.connect: 1000
!!gossipsub.iwant: 163
!!pubsub.publish: 65328

> (simple-gossipsub-simulation trace: void messages: 1000 message-delay: .01)
=== simulation summary ===
nodes: 100
messages: 1000
fanout: 5
publish: 5000
deliver: 100000
!!gossipsub.ihave: 14196
!!gossipsub.link: 366
!!gossipsub.graft: 366
!!pubsub.connect: 1000
!!gossipsub.iwant: 1219
!!pubsub.publish: 627418

#+END_EXAMPLE

If you want to see a trace of the developing simulation,
then omit the ~trace: void~ argument to the simulation invocation.
The default ~trace:~ will be ~displayln~, which will print out the simulation
in the current output port.

* License

MIT; Â© 2018 vyzo
